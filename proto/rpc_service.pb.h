// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpc_service.proto

#ifndef PROTOBUF_rpc_5fservice_2eproto__INCLUDED
#define PROTOBUF_rpc_5fservice_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "tensorflow/core/framework/tensor.pb.h"
// @@protoc_insertion_point(includes)
namespace adaptive_system {
class Empty;
class EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class Gradient;
class GradientDefaultTypeInternal;
extern GradientDefaultTypeInternal _Gradient_default_instance_;
class GradientAndLoss;
class GradientAndLossDefaultTypeInternal;
extern GradientAndLossDefaultTypeInternal _GradientAndLoss_default_instance_;
class PartialState;
class PartialStateDefaultTypeInternal;
extern PartialStateDefaultTypeInternal _PartialState_default_instance_;
class PartialStateAndLoss;
class PartialStateAndLossDefaultTypeInternal;
extern PartialStateAndLossDefaultTypeInternal _PartialStateAndLoss_default_instance_;
class QuantizationLevel;
class QuantizationLevelDefaultTypeInternal;
extern QuantizationLevelDefaultTypeInternal _QuantizationLevel_default_instance_;
class TuplePaLrItv;
class TuplePaLrItvDefaultTypeInternal;
extern TuplePaLrItvDefaultTypeInternal _TuplePaLrItv_default_instance_;
}  // namespace adaptive_system
namespace tensorflow {
class TensorProto;
class TensorProtoDefaultTypeInternal;
extern TensorProtoDefaultTypeInternal _TensorProto_default_instance_;
}  // namespace tensorflow

namespace adaptive_system {

namespace protobuf_rpc_5fservice_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_rpc_5fservice_2eproto

enum GRAD_QUANT_LEVEL {
  TWO = 0,
  FOUR = 1,
  EIGHT = 2,
  SIXTEEN = 3,
  NONE = 4,
  GRAD_QUANT_LEVEL_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GRAD_QUANT_LEVEL_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GRAD_QUANT_LEVEL_IsValid(int value);
const GRAD_QUANT_LEVEL GRAD_QUANT_LEVEL_MIN = TWO;
const GRAD_QUANT_LEVEL GRAD_QUANT_LEVEL_MAX = NONE;
const int GRAD_QUANT_LEVEL_ARRAYSIZE = GRAD_QUANT_LEVEL_MAX + 1;

const ::google::protobuf::EnumDescriptor* GRAD_QUANT_LEVEL_descriptor();
inline const ::std::string& GRAD_QUANT_LEVEL_Name(GRAD_QUANT_LEVEL value) {
  return ::google::protobuf::internal::NameOfEnum(
    GRAD_QUANT_LEVEL_descriptor(), value);
}
inline bool GRAD_QUANT_LEVEL_Parse(
    const ::std::string& name, GRAD_QUANT_LEVEL* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GRAD_QUANT_LEVEL>(
    GRAD_QUANT_LEVEL_descriptor(), name, value);
}
// ===================================================================

class Empty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adaptive_system.Empty) */ {
 public:
  Empty();
  virtual ~Empty();

  Empty(const Empty& from);

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Empty& default_instance();

  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }

  void Swap(Empty* other);

  // implements Message ----------------------------------------------

  inline Empty* New() const PROTOBUF_FINAL { return New(NULL); }

  Empty* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Empty& from);
  void MergeFrom(const Empty& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Empty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:adaptive_system.Empty)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_rpc_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TuplePaLrItv : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adaptive_system.TuplePaLrItv) */ {
 public:
  TuplePaLrItv();
  virtual ~TuplePaLrItv();

  TuplePaLrItv(const TuplePaLrItv& from);

  inline TuplePaLrItv& operator=(const TuplePaLrItv& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TuplePaLrItv& default_instance();

  static inline const TuplePaLrItv* internal_default_instance() {
    return reinterpret_cast<const TuplePaLrItv*>(
               &_TuplePaLrItv_default_instance_);
  }

  void Swap(TuplePaLrItv* other);

  // implements Message ----------------------------------------------

  inline TuplePaLrItv* New() const PROTOBUF_FINAL { return New(NULL); }

  TuplePaLrItv* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TuplePaLrItv& from);
  void MergeFrom(const TuplePaLrItv& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TuplePaLrItv* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.TensorProto parameter = 1;
  bool has_parameter() const;
  void clear_parameter();
  static const int kParameterFieldNumber = 1;
  const ::tensorflow::TensorProto& parameter() const;
  ::tensorflow::TensorProto* mutable_parameter();
  ::tensorflow::TensorProto* release_parameter();
  void set_allocated_parameter(::tensorflow::TensorProto* parameter);

  // float lr = 2;
  void clear_lr();
  static const int kLrFieldNumber = 2;
  float lr() const;
  void set_lr(float value);

  // int32 interval = 3;
  void clear_interval();
  static const int kIntervalFieldNumber = 3;
  ::google::protobuf::int32 interval() const;
  void set_interval(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:adaptive_system.TuplePaLrItv)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::TensorProto* parameter_;
  float lr_;
  ::google::protobuf::int32 interval_;
  mutable int _cached_size_;
  friend struct protobuf_rpc_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QuantizationLevel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adaptive_system.QuantizationLevel) */ {
 public:
  QuantizationLevel();
  virtual ~QuantizationLevel();

  QuantizationLevel(const QuantizationLevel& from);

  inline QuantizationLevel& operator=(const QuantizationLevel& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QuantizationLevel& default_instance();

  static inline const QuantizationLevel* internal_default_instance() {
    return reinterpret_cast<const QuantizationLevel*>(
               &_QuantizationLevel_default_instance_);
  }

  void Swap(QuantizationLevel* other);

  // implements Message ----------------------------------------------

  inline QuantizationLevel* New() const PROTOBUF_FINAL { return New(NULL); }

  QuantizationLevel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QuantizationLevel& from);
  void MergeFrom(const QuantizationLevel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QuantizationLevel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .adaptive_system.GRAD_QUANT_LEVEL level = 1;
  void clear_level();
  static const int kLevelFieldNumber = 1;
  ::adaptive_system::GRAD_QUANT_LEVEL level() const;
  void set_level(::adaptive_system::GRAD_QUANT_LEVEL value);

  // @@protoc_insertion_point(class_scope:adaptive_system.QuantizationLevel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int level_;
  mutable int _cached_size_;
  friend struct protobuf_rpc_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Gradient : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adaptive_system.Gradient) */ {
 public:
  Gradient();
  virtual ~Gradient();

  Gradient(const Gradient& from);

  inline Gradient& operator=(const Gradient& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Gradient& default_instance();

  static inline const Gradient* internal_default_instance() {
    return reinterpret_cast<const Gradient*>(
               &_Gradient_default_instance_);
  }

  void Swap(Gradient* other);

  // implements Message ----------------------------------------------

  inline Gradient* New() const PROTOBUF_FINAL { return New(NULL); }

  Gradient* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Gradient& from);
  void MergeFrom(const Gradient& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Gradient* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes tensor_le_8 = 3;
  void clear_tensor_le_8();
  static const int kTensorLe8FieldNumber = 3;
  const ::std::string& tensor_le_8() const;
  void set_tensor_le_8(const ::std::string& value);
  #if LANG_CXX11
  void set_tensor_le_8(::std::string&& value);
  #endif
  void set_tensor_le_8(const char* value);
  void set_tensor_le_8(const void* value, size_t size);
  ::std::string* mutable_tensor_le_8();
  ::std::string* release_tensor_le_8();
  void set_allocated_tensor_le_8(::std::string* tensor_le_8);

  // .tensorflow.TensorProto tensor_ge_8 = 2;
  bool has_tensor_ge_8() const;
  void clear_tensor_ge_8();
  static const int kTensorGe8FieldNumber = 2;
  const ::tensorflow::TensorProto& tensor_ge_8() const;
  ::tensorflow::TensorProto* mutable_tensor_ge_8();
  ::tensorflow::TensorProto* release_tensor_ge_8();
  void set_allocated_tensor_ge_8(::tensorflow::TensorProto* tensor_ge_8);

  // .adaptive_system.GRAD_QUANT_LEVEL level = 1;
  void clear_level();
  static const int kLevelFieldNumber = 1;
  ::adaptive_system::GRAD_QUANT_LEVEL level() const;
  void set_level(::adaptive_system::GRAD_QUANT_LEVEL value);

  // float max = 4;
  void clear_max();
  static const int kMaxFieldNumber = 4;
  float max() const;
  void set_max(float value);

  // float min = 5;
  void clear_min();
  static const int kMinFieldNumber = 5;
  float min() const;
  void set_min(float value);

  // @@protoc_insertion_point(class_scope:adaptive_system.Gradient)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tensor_le_8_;
  ::tensorflow::TensorProto* tensor_ge_8_;
  int level_;
  float max_;
  float min_;
  mutable int _cached_size_;
  friend struct protobuf_rpc_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PartialState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adaptive_system.PartialState) */ {
 public:
  PartialState();
  virtual ~PartialState();

  PartialState(const PartialState& from);

  inline PartialState& operator=(const PartialState& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PartialState& default_instance();

  static inline const PartialState* internal_default_instance() {
    return reinterpret_cast<const PartialState*>(
               &_PartialState_default_instance_);
  }

  void Swap(PartialState* other);

  // implements Message ----------------------------------------------

  inline PartialState* New() const PROTOBUF_FINAL { return New(NULL); }

  PartialState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PartialState& from);
  void MergeFrom(const PartialState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PartialState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.TensorProto tensor = 1;
  bool has_tensor() const;
  void clear_tensor();
  static const int kTensorFieldNumber = 1;
  const ::tensorflow::TensorProto& tensor() const;
  ::tensorflow::TensorProto* mutable_tensor();
  ::tensorflow::TensorProto* release_tensor();
  void set_allocated_tensor(::tensorflow::TensorProto* tensor);

  // @@protoc_insertion_point(class_scope:adaptive_system.PartialState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::TensorProto* tensor_;
  mutable int _cached_size_;
  friend struct protobuf_rpc_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GradientAndLoss : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adaptive_system.GradientAndLoss) */ {
 public:
  GradientAndLoss();
  virtual ~GradientAndLoss();

  GradientAndLoss(const GradientAndLoss& from);

  inline GradientAndLoss& operator=(const GradientAndLoss& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GradientAndLoss& default_instance();

  static inline const GradientAndLoss* internal_default_instance() {
    return reinterpret_cast<const GradientAndLoss*>(
               &_GradientAndLoss_default_instance_);
  }

  void Swap(GradientAndLoss* other);

  // implements Message ----------------------------------------------

  inline GradientAndLoss* New() const PROTOBUF_FINAL { return New(NULL); }

  GradientAndLoss* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GradientAndLoss& from);
  void MergeFrom(const GradientAndLoss& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GradientAndLoss* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .adaptive_system.Gradient grad = 1;
  bool has_grad() const;
  void clear_grad();
  static const int kGradFieldNumber = 1;
  const ::adaptive_system::Gradient& grad() const;
  ::adaptive_system::Gradient* mutable_grad();
  ::adaptive_system::Gradient* release_grad();
  void set_allocated_grad(::adaptive_system::Gradient* grad);

  // float loss = 2;
  void clear_loss();
  static const int kLossFieldNumber = 2;
  float loss() const;
  void set_loss(float value);

  // @@protoc_insertion_point(class_scope:adaptive_system.GradientAndLoss)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::adaptive_system::Gradient* grad_;
  float loss_;
  mutable int _cached_size_;
  friend struct protobuf_rpc_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PartialStateAndLoss : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adaptive_system.PartialStateAndLoss) */ {
 public:
  PartialStateAndLoss();
  virtual ~PartialStateAndLoss();

  PartialStateAndLoss(const PartialStateAndLoss& from);

  inline PartialStateAndLoss& operator=(const PartialStateAndLoss& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PartialStateAndLoss& default_instance();

  static inline const PartialStateAndLoss* internal_default_instance() {
    return reinterpret_cast<const PartialStateAndLoss*>(
               &_PartialStateAndLoss_default_instance_);
  }

  void Swap(PartialStateAndLoss* other);

  // implements Message ----------------------------------------------

  inline PartialStateAndLoss* New() const PROTOBUF_FINAL { return New(NULL); }

  PartialStateAndLoss* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PartialStateAndLoss& from);
  void MergeFrom(const PartialStateAndLoss& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PartialStateAndLoss* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .adaptive_system.PartialState ps = 1;
  bool has_ps() const;
  void clear_ps();
  static const int kPsFieldNumber = 1;
  const ::adaptive_system::PartialState& ps() const;
  ::adaptive_system::PartialState* mutable_ps();
  ::adaptive_system::PartialState* release_ps();
  void set_allocated_ps(::adaptive_system::PartialState* ps);

  // float loss = 2;
  void clear_loss();
  static const int kLossFieldNumber = 2;
  float loss() const;
  void set_loss(float value);

  // @@protoc_insertion_point(class_scope:adaptive_system.PartialStateAndLoss)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::adaptive_system::PartialState* ps_;
  float loss_;
  mutable int _cached_size_;
  friend struct protobuf_rpc_5fservice_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Empty

// -------------------------------------------------------------------

// TuplePaLrItv

// .tensorflow.TensorProto parameter = 1;
inline bool TuplePaLrItv::has_parameter() const {
  return this != internal_default_instance() && parameter_ != NULL;
}
inline void TuplePaLrItv::clear_parameter() {
  if (GetArenaNoVirtual() == NULL && parameter_ != NULL) delete parameter_;
  parameter_ = NULL;
}
inline const ::tensorflow::TensorProto& TuplePaLrItv::parameter() const {
  // @@protoc_insertion_point(field_get:adaptive_system.TuplePaLrItv.parameter)
  return parameter_ != NULL ? *parameter_
                         : *::tensorflow::TensorProto::internal_default_instance();
}
inline ::tensorflow::TensorProto* TuplePaLrItv::mutable_parameter() {
  
  if (parameter_ == NULL) {
    parameter_ = new ::tensorflow::TensorProto;
  }
  // @@protoc_insertion_point(field_mutable:adaptive_system.TuplePaLrItv.parameter)
  return parameter_;
}
inline ::tensorflow::TensorProto* TuplePaLrItv::release_parameter() {
  // @@protoc_insertion_point(field_release:adaptive_system.TuplePaLrItv.parameter)
  
  ::tensorflow::TensorProto* temp = parameter_;
  parameter_ = NULL;
  return temp;
}
inline void TuplePaLrItv::set_allocated_parameter(::tensorflow::TensorProto* parameter) {
  delete parameter_;
  if (parameter != NULL && parameter->GetArena() != NULL) {
    ::tensorflow::TensorProto* new_parameter = new ::tensorflow::TensorProto;
    new_parameter->CopyFrom(*parameter);
    parameter = new_parameter;
  }
  parameter_ = parameter;
  if (parameter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:adaptive_system.TuplePaLrItv.parameter)
}

// float lr = 2;
inline void TuplePaLrItv::clear_lr() {
  lr_ = 0;
}
inline float TuplePaLrItv::lr() const {
  // @@protoc_insertion_point(field_get:adaptive_system.TuplePaLrItv.lr)
  return lr_;
}
inline void TuplePaLrItv::set_lr(float value) {
  
  lr_ = value;
  // @@protoc_insertion_point(field_set:adaptive_system.TuplePaLrItv.lr)
}

// int32 interval = 3;
inline void TuplePaLrItv::clear_interval() {
  interval_ = 0;
}
inline ::google::protobuf::int32 TuplePaLrItv::interval() const {
  // @@protoc_insertion_point(field_get:adaptive_system.TuplePaLrItv.interval)
  return interval_;
}
inline void TuplePaLrItv::set_interval(::google::protobuf::int32 value) {
  
  interval_ = value;
  // @@protoc_insertion_point(field_set:adaptive_system.TuplePaLrItv.interval)
}

// -------------------------------------------------------------------

// QuantizationLevel

// .adaptive_system.GRAD_QUANT_LEVEL level = 1;
inline void QuantizationLevel::clear_level() {
  level_ = 0;
}
inline ::adaptive_system::GRAD_QUANT_LEVEL QuantizationLevel::level() const {
  // @@protoc_insertion_point(field_get:adaptive_system.QuantizationLevel.level)
  return static_cast< ::adaptive_system::GRAD_QUANT_LEVEL >(level_);
}
inline void QuantizationLevel::set_level(::adaptive_system::GRAD_QUANT_LEVEL value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:adaptive_system.QuantizationLevel.level)
}

// -------------------------------------------------------------------

// Gradient

// .adaptive_system.GRAD_QUANT_LEVEL level = 1;
inline void Gradient::clear_level() {
  level_ = 0;
}
inline ::adaptive_system::GRAD_QUANT_LEVEL Gradient::level() const {
  // @@protoc_insertion_point(field_get:adaptive_system.Gradient.level)
  return static_cast< ::adaptive_system::GRAD_QUANT_LEVEL >(level_);
}
inline void Gradient::set_level(::adaptive_system::GRAD_QUANT_LEVEL value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:adaptive_system.Gradient.level)
}

// .tensorflow.TensorProto tensor_ge_8 = 2;
inline bool Gradient::has_tensor_ge_8() const {
  return this != internal_default_instance() && tensor_ge_8_ != NULL;
}
inline void Gradient::clear_tensor_ge_8() {
  if (GetArenaNoVirtual() == NULL && tensor_ge_8_ != NULL) delete tensor_ge_8_;
  tensor_ge_8_ = NULL;
}
inline const ::tensorflow::TensorProto& Gradient::tensor_ge_8() const {
  // @@protoc_insertion_point(field_get:adaptive_system.Gradient.tensor_ge_8)
  return tensor_ge_8_ != NULL ? *tensor_ge_8_
                         : *::tensorflow::TensorProto::internal_default_instance();
}
inline ::tensorflow::TensorProto* Gradient::mutable_tensor_ge_8() {
  
  if (tensor_ge_8_ == NULL) {
    tensor_ge_8_ = new ::tensorflow::TensorProto;
  }
  // @@protoc_insertion_point(field_mutable:adaptive_system.Gradient.tensor_ge_8)
  return tensor_ge_8_;
}
inline ::tensorflow::TensorProto* Gradient::release_tensor_ge_8() {
  // @@protoc_insertion_point(field_release:adaptive_system.Gradient.tensor_ge_8)
  
  ::tensorflow::TensorProto* temp = tensor_ge_8_;
  tensor_ge_8_ = NULL;
  return temp;
}
inline void Gradient::set_allocated_tensor_ge_8(::tensorflow::TensorProto* tensor_ge_8) {
  delete tensor_ge_8_;
  if (tensor_ge_8 != NULL && tensor_ge_8->GetArena() != NULL) {
    ::tensorflow::TensorProto* new_tensor_ge_8 = new ::tensorflow::TensorProto;
    new_tensor_ge_8->CopyFrom(*tensor_ge_8);
    tensor_ge_8 = new_tensor_ge_8;
  }
  tensor_ge_8_ = tensor_ge_8;
  if (tensor_ge_8) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:adaptive_system.Gradient.tensor_ge_8)
}

// bytes tensor_le_8 = 3;
inline void Gradient::clear_tensor_le_8() {
  tensor_le_8_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Gradient::tensor_le_8() const {
  // @@protoc_insertion_point(field_get:adaptive_system.Gradient.tensor_le_8)
  return tensor_le_8_.GetNoArena();
}
inline void Gradient::set_tensor_le_8(const ::std::string& value) {
  
  tensor_le_8_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:adaptive_system.Gradient.tensor_le_8)
}
#if LANG_CXX11
inline void Gradient::set_tensor_le_8(::std::string&& value) {
  
  tensor_le_8_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:adaptive_system.Gradient.tensor_le_8)
}
#endif
inline void Gradient::set_tensor_le_8(const char* value) {
  
  tensor_le_8_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:adaptive_system.Gradient.tensor_le_8)
}
inline void Gradient::set_tensor_le_8(const void* value, size_t size) {
  
  tensor_le_8_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:adaptive_system.Gradient.tensor_le_8)
}
inline ::std::string* Gradient::mutable_tensor_le_8() {
  
  // @@protoc_insertion_point(field_mutable:adaptive_system.Gradient.tensor_le_8)
  return tensor_le_8_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Gradient::release_tensor_le_8() {
  // @@protoc_insertion_point(field_release:adaptive_system.Gradient.tensor_le_8)
  
  return tensor_le_8_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Gradient::set_allocated_tensor_le_8(::std::string* tensor_le_8) {
  if (tensor_le_8 != NULL) {
    
  } else {
    
  }
  tensor_le_8_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tensor_le_8);
  // @@protoc_insertion_point(field_set_allocated:adaptive_system.Gradient.tensor_le_8)
}

// float max = 4;
inline void Gradient::clear_max() {
  max_ = 0;
}
inline float Gradient::max() const {
  // @@protoc_insertion_point(field_get:adaptive_system.Gradient.max)
  return max_;
}
inline void Gradient::set_max(float value) {
  
  max_ = value;
  // @@protoc_insertion_point(field_set:adaptive_system.Gradient.max)
}

// float min = 5;
inline void Gradient::clear_min() {
  min_ = 0;
}
inline float Gradient::min() const {
  // @@protoc_insertion_point(field_get:adaptive_system.Gradient.min)
  return min_;
}
inline void Gradient::set_min(float value) {
  
  min_ = value;
  // @@protoc_insertion_point(field_set:adaptive_system.Gradient.min)
}

// -------------------------------------------------------------------

// PartialState

// .tensorflow.TensorProto tensor = 1;
inline bool PartialState::has_tensor() const {
  return this != internal_default_instance() && tensor_ != NULL;
}
inline void PartialState::clear_tensor() {
  if (GetArenaNoVirtual() == NULL && tensor_ != NULL) delete tensor_;
  tensor_ = NULL;
}
inline const ::tensorflow::TensorProto& PartialState::tensor() const {
  // @@protoc_insertion_point(field_get:adaptive_system.PartialState.tensor)
  return tensor_ != NULL ? *tensor_
                         : *::tensorflow::TensorProto::internal_default_instance();
}
inline ::tensorflow::TensorProto* PartialState::mutable_tensor() {
  
  if (tensor_ == NULL) {
    tensor_ = new ::tensorflow::TensorProto;
  }
  // @@protoc_insertion_point(field_mutable:adaptive_system.PartialState.tensor)
  return tensor_;
}
inline ::tensorflow::TensorProto* PartialState::release_tensor() {
  // @@protoc_insertion_point(field_release:adaptive_system.PartialState.tensor)
  
  ::tensorflow::TensorProto* temp = tensor_;
  tensor_ = NULL;
  return temp;
}
inline void PartialState::set_allocated_tensor(::tensorflow::TensorProto* tensor) {
  delete tensor_;
  if (tensor != NULL && tensor->GetArena() != NULL) {
    ::tensorflow::TensorProto* new_tensor = new ::tensorflow::TensorProto;
    new_tensor->CopyFrom(*tensor);
    tensor = new_tensor;
  }
  tensor_ = tensor;
  if (tensor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:adaptive_system.PartialState.tensor)
}

// -------------------------------------------------------------------

// GradientAndLoss

// .adaptive_system.Gradient grad = 1;
inline bool GradientAndLoss::has_grad() const {
  return this != internal_default_instance() && grad_ != NULL;
}
inline void GradientAndLoss::clear_grad() {
  if (GetArenaNoVirtual() == NULL && grad_ != NULL) delete grad_;
  grad_ = NULL;
}
inline const ::adaptive_system::Gradient& GradientAndLoss::grad() const {
  // @@protoc_insertion_point(field_get:adaptive_system.GradientAndLoss.grad)
  return grad_ != NULL ? *grad_
                         : *::adaptive_system::Gradient::internal_default_instance();
}
inline ::adaptive_system::Gradient* GradientAndLoss::mutable_grad() {
  
  if (grad_ == NULL) {
    grad_ = new ::adaptive_system::Gradient;
  }
  // @@protoc_insertion_point(field_mutable:adaptive_system.GradientAndLoss.grad)
  return grad_;
}
inline ::adaptive_system::Gradient* GradientAndLoss::release_grad() {
  // @@protoc_insertion_point(field_release:adaptive_system.GradientAndLoss.grad)
  
  ::adaptive_system::Gradient* temp = grad_;
  grad_ = NULL;
  return temp;
}
inline void GradientAndLoss::set_allocated_grad(::adaptive_system::Gradient* grad) {
  delete grad_;
  grad_ = grad;
  if (grad) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:adaptive_system.GradientAndLoss.grad)
}

// float loss = 2;
inline void GradientAndLoss::clear_loss() {
  loss_ = 0;
}
inline float GradientAndLoss::loss() const {
  // @@protoc_insertion_point(field_get:adaptive_system.GradientAndLoss.loss)
  return loss_;
}
inline void GradientAndLoss::set_loss(float value) {
  
  loss_ = value;
  // @@protoc_insertion_point(field_set:adaptive_system.GradientAndLoss.loss)
}

// -------------------------------------------------------------------

// PartialStateAndLoss

// .adaptive_system.PartialState ps = 1;
inline bool PartialStateAndLoss::has_ps() const {
  return this != internal_default_instance() && ps_ != NULL;
}
inline void PartialStateAndLoss::clear_ps() {
  if (GetArenaNoVirtual() == NULL && ps_ != NULL) delete ps_;
  ps_ = NULL;
}
inline const ::adaptive_system::PartialState& PartialStateAndLoss::ps() const {
  // @@protoc_insertion_point(field_get:adaptive_system.PartialStateAndLoss.ps)
  return ps_ != NULL ? *ps_
                         : *::adaptive_system::PartialState::internal_default_instance();
}
inline ::adaptive_system::PartialState* PartialStateAndLoss::mutable_ps() {
  
  if (ps_ == NULL) {
    ps_ = new ::adaptive_system::PartialState;
  }
  // @@protoc_insertion_point(field_mutable:adaptive_system.PartialStateAndLoss.ps)
  return ps_;
}
inline ::adaptive_system::PartialState* PartialStateAndLoss::release_ps() {
  // @@protoc_insertion_point(field_release:adaptive_system.PartialStateAndLoss.ps)
  
  ::adaptive_system::PartialState* temp = ps_;
  ps_ = NULL;
  return temp;
}
inline void PartialStateAndLoss::set_allocated_ps(::adaptive_system::PartialState* ps) {
  delete ps_;
  ps_ = ps;
  if (ps) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:adaptive_system.PartialStateAndLoss.ps)
}

// float loss = 2;
inline void PartialStateAndLoss::clear_loss() {
  loss_ = 0;
}
inline float PartialStateAndLoss::loss() const {
  // @@protoc_insertion_point(field_get:adaptive_system.PartialStateAndLoss.loss)
  return loss_;
}
inline void PartialStateAndLoss::set_loss(float value) {
  
  loss_ = value;
  // @@protoc_insertion_point(field_set:adaptive_system.PartialStateAndLoss.loss)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace adaptive_system

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::adaptive_system::GRAD_QUANT_LEVEL> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::adaptive_system::GRAD_QUANT_LEVEL>() {
  return ::adaptive_system::GRAD_QUANT_LEVEL_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rpc_5fservice_2eproto__INCLUDED
